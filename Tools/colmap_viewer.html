<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colmap Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer" style="width: 100vw; height: 0vh;"></div>
    <h2 style="color: white;">Choose Colmap Sparse Model</h2>
    <input style="color: white;" type="file" webkitdirectory directory multiple id="folderInput">
    <pre id="output" style="color: white;"></pre>
    <label style="color: white;">点大小: <input type="range" id="pointSize" min="0.01" max="2" step="0.01" value="0.05"></label>
    <label style="color: white;">相机大小: <input type="range" id="cameraSize" min="0.1" max="5" step="0.1" value="0.5"></label>
    <label style="color: white;">显示图片名称: <input type="checkbox" id="showLabels" checked></label>
    <label style="color: white;">文件夹过滤: 
        <select id="folderFilter" style="color: black;">
            <option value="">显示所有</option>
        </select>
    </label>

    <script>
        let scene, camera, renderer, controls, pointCloud, camerasGroup, labelsGroup;
        let constantOffsetX = -0.5 * Math.PI;
        let imagesData = [];
        let availableFolders = [];

        document.getElementById("pointSize").addEventListener("input", handlePointSize);
        document.getElementById("cameraSize").addEventListener("input", handleCameraSize);
        document.getElementById("showLabels").addEventListener("change", handleShowLabels);
        document.getElementById("folderFilter").addEventListener("change", handleFolderFilter);

        function handlePointSize(event) {
            if (pointCloud == null) return;
            pointCloud.material.size = event.target.value;
        }

        function handleCameraSize(event) {
            if (camerasGroup == null) return;
            recreateCameraGroup();
        }

        function handleShowLabels(event) {
            if (labelsGroup == null) return;
            labelsGroup.visible = event.target.checked;
        }

        function handleFolderFilter(event) {
            if (imagesData.length === 0) return;
            recreateCameraGroup();
            recreateLabels();
        }

        function extractFolderFromPath(imageName) {
            // 从路径中提取文件夹名，如 "GS010101_x/xxxxx.jpg" -> "GS010101_x"
            const parts = imageName.split('/');
            if (parts.length > 1) {
                return parts[0];
            }
            return '';
        }

        function updateFolderFilter(images) {
            const folders = new Set();
            images.forEach(img => {
                const folder = extractFolderFromPath(img.imageName);
                if (folder) {
                    folders.add(folder);
                }
            });
            
            availableFolders = Array.from(folders).sort();
            const filterSelect = document.getElementById('folderFilter');
            
            // 清除现有选项（除了"显示所有"）
            filterSelect.innerHTML = '<option value="">显示所有</option>';
            
            // 添加新的文件夹选项
            availableFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder;
                option.textContent = folder;
                filterSelect.appendChild(option);
            });
        }

        function shouldShowImage(imageName) {
            const selectedFolder = document.getElementById('folderFilter').value;
            if (!selectedFolder) return true; // 显示所有
            
            const imageFolder = extractFolderFromPath(imageName);
            return imageFolder === selectedFolder;
        }

        function createTextSprite(text, color = '#ffffff', size = 16) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // 设置字体
            context.font = `${size}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 测量文本尺寸
            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            const textHeight = size;
            
            // 设置画布尺寸
            canvas.width = textWidth + 20;
            canvas.height = textHeight + 10;
            
            // 重新设置字体（画布大小改变后需要重设）
            context.font = `${size}px Arial`;
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // 调整精灵大小
            const scale = 0.5;
            sprite.scale.set(canvas.width * 0.01 * scale, canvas.height * 0.01 * scale, 1);
            
            return sprite;
        }

        function recreateCameraGroup() {
            if (camerasGroup) {
                scene.remove(camerasGroup);
            }

            const cameraSize = parseFloat(document.getElementById('cameraSize').value);
            camerasGroup = new THREE.Group();

            imagesData.forEach(img => {
                if (!shouldShowImage(img.imageName)) return;

                const camMesh = new THREE.AxesHelper(cameraSize);
                camMesh.position.set(...img.position);
                camMesh.setRotationFromMatrix(img.rotationMatrix);
                camerasGroup.add(camMesh);
            });

            camerasGroup.rotation.x = constantOffsetX;
            scene.add(camerasGroup);
        }

        function recreateLabels() {
            if (labelsGroup) {
                scene.remove(labelsGroup);
            }

            const showLabels = document.getElementById('showLabels').checked;
            if (!showLabels) return;

            labelsGroup = new THREE.Group();

            imagesData.forEach(img => {
                if (!shouldShowImage(img.imageName)) return;

                // 提取文件名（不包括路径）
                const fileName = img.imageName.split('/').pop();
                // 移除扩展名
                const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
                
                const textSprite = createTextSprite(nameWithoutExt);
                textSprite.position.set(
                    img.position[0],
                    img.position[1] + 0.3, // 稍微偏移到相机上方
                    img.position[2]
                );
                labelsGroup.add(textSprite);
            });

            labelsGroup.rotation.x = constantOffsetX;
            scene.add(labelsGroup);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('viewer').appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(0, 0, 5);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        document.getElementById('folderInput').addEventListener('change', async function(event) {
            const files = event.target.files;
            let fileMap = {};

            for (let file of files) {
                fileMap[file.name] = file;
            }

            let stats = {};
            if (fileMap['images.bin']) {
              stats.images = await parseColmapBin(fileMap['images.bin']);
            } else if (fileMap['images.txt']) {
              stats.images = await parseImages(fileMap['images.txt']);
            } else {
              document.getElementById('output').textContent = '错误：缺少必要的Colmap稀疏重建文件';
              return;
            }

            if (fileMap['points3D.bin']) {
              stats.points3D = await parsePoints3DBin(fileMap['points3D.bin']);
            } else if (fileMap['points3D.txt']) {
              stats.points3D = await parsePoints3D(fileMap['points3D.txt']);
            } else {
              document.getElementById('output').textContent = '错误：缺少必要的Colmap稀疏重建文件';
              return;
            }

            imagesData = stats.images;
            updateFolderFilter(imagesData);

            document.getElementById('output').textContent = `\n相机数量: ${stats.images.length}\n点云点数: ${stats.points3D.points.length}`;

            visualizeScene(stats.images, stats.points3D);
        });

        async function parseColmapBin(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const buffer = event.target.result;
                    const view = new DataView(buffer);
                    let offset = 0;

                    function readUint64() {
                        let low = view.getUint32(offset, true);
                        let high = view.getUint32(offset + 4, true);
                        offset += 8;
                        return high * 2 ** 32 + low;
                    }

                    function readInt32() {
                        let value = view.getInt32(offset, true);
                        offset += 4;
                        return value;
                    }

                    function readFloat64() {
                        let value = view.getFloat64(offset, true);
                        offset += 8;
                        return value;
                    }

                    function readString() {
                        let str = "";
                        while (offset < buffer.byteLength) {
                            let char = view.getUint8(offset++);
                            if (char === 0) break;
                            str += String.fromCharCode(char);
                        }
                        return str;
                    }

                    const numImages = readUint64();
                    let poses = [];

                    for (let i = 0; i < numImages; i++) {
                        const imageId = readInt32();
                        let qvec = [readFloat64(), readFloat64(), readFloat64(), readFloat64()];
                        let tvec = [readFloat64(), readFloat64(), readFloat64()];
                        const cameraId = readInt32();
                        const imageName = readString();

                        const numPoints2D = readUint64();
                        offset += numPoints2D * (8 + 8 + 8);

                        let quaternion = new THREE.Quaternion(qvec[1], qvec[2], qvec[3], qvec[0]);
                        let rotationMatrix = new THREE.Matrix4();
                        rotationMatrix.makeRotationFromQuaternion(quaternion);

                        let translation = new THREE.Vector3(-tvec[0], -tvec[1], -tvec[2]);
                        let cameraPosition = translation.applyMatrix4(rotationMatrix.clone().transpose());

                        poses.push({
                            position: [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                            quaternion: qvec,
                            rotationMatrix,
                            imageName: imageName
                        });
                    }

                    resolve(poses);
                };

                reader.readAsArrayBuffer(file);
            });
        }

        async function parseImages(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const lines = event.target.result.split('\n').filter(line => !line.startsWith('#') && line.trim() !== '');
                    let poses = [];
                    for (let i = 0; i < lines.length; i += 2) {
                        const data = lines[i].split(' ');
                        let qw = parseFloat(data[1]);
                        let qx = parseFloat(data[2]);
                        let qy = parseFloat(data[3]);
                        let qz = parseFloat(data[4]);
                        let tx = parseFloat(data[5]);
                        let ty = parseFloat(data[6]);
                        let tz = parseFloat(data[7]);
                        let imageName = data.slice(9).join(' '); // 图片名可能包含空格

                        let quaternion = new THREE.Quaternion(qx, qy, qz, qw);
                        let translation = new THREE.Vector3(tx, ty, tz);

                        let rotationMatrix = new THREE.Matrix4();
                        rotationMatrix.makeRotationFromQuaternion(quaternion);
                        rotationMatrix.transpose();

                        let cameraPosition = translation.applyMatrix4(rotationMatrix.clone());
                        poses.push({ 
                            position: [-cameraPosition.x, -cameraPosition.y, -cameraPosition.z], 
                            quaternion: [qx, qy, qz, qw], 
                            rotationMatrix,
                            imageName: imageName
                        });
                    }
                    resolve(poses);
                };
                reader.readAsText(file);
            });
        }

        async function parsePoints3D(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const lines = event.target.result.split('\n').filter(line => !line.startsWith('#') && line.trim() !== '');
                    let points = [];
                    let colors = [];
                    for (let line of lines) {
                        const data = line.split(' ');
                        let x = parseFloat(data[1]);
                        let y = parseFloat(data[2]);
                        let z = parseFloat(data[3]);
                        let r = parseInt(data[4]) / 255;
                        let g = parseInt(data[5]) / 255;
                        let b = parseInt(data[6]) / 255;
                        points.push([x, y, z]);
                        colors.push([r, g, b]);
                    }
                    resolve({ points, colors });
                };
                reader.readAsText(file);
            });
        }

        async function parsePoints3DBin(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const buffer = event.target.result;
                    const view = new DataView(buffer);
                    let offset = 0;

                    function readUint64() {
                        let low = view.getUint32(offset, true);
                        let high = view.getUint32(offset + 4, true);
                        offset += 8;
                        return high * 2 ** 32 + low;
                    }

                    function readFloat64() {
                        let value = view.getFloat64(offset, true);
                        offset += 8;
                        return value;
                    }

                    function readUint8() {
                        let value = view.getUint8(offset);
                        offset += 1;
                        return value;
                    }

                    function readInt32() {
                        let value = view.getInt32(offset, true);
                        offset += 4;
                        return value;
                    }

                    const numPoints = readUint64();
                    let points = [];
                    let colors = [];

                    for (let i = 0; i < numPoints; i++) {
                        let point3DId = readUint64();
                        let x = readFloat64();
                        let y = readFloat64();
                        let z = readFloat64();
                        let r = readUint8() / 255;
                        let g = readUint8() / 255;
                        let b = readUint8() / 255;
                        let error = readFloat64();
                        let trackLength = readUint64();

                        let imageIds = [];
                        let point2DIndices = [];

                        for (let j = 0; j < trackLength; j++) {
                            imageIds.push(readInt32());
                            point2DIndices.push(readInt32());
                        }

                        points.push([x, y, z]);
                        colors.push([r, g, b]);
                    }

                    resolve({ points, colors });
                };

                reader.readAsArrayBuffer(file);
            });
        }

        function visualizeScene(images, pointData) {
            // 清理当前场景
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            
            // 添加坐标系
            const axesHelper = new THREE.AxesHelper(100);
            axesHelper.rotation.x = constantOffsetX;
            scene.add(axesHelper);

            // 添加点云
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(pointData.points.flat());
            const colors = new Float32Array(pointData.colors.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ vertexColors: true, size: parseFloat(document.getElementById('pointSize').value) });
            pointCloud = new THREE.Points(geometry, material);
            pointCloud.rotation.x = constantOffsetX;
            scene.add(pointCloud);

            // 创建相机组和标签
            recreateCameraGroup();
            recreateLabels();
        }

        initThreeJS();
    </script>
</body>
</html>